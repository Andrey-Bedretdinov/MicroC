# Объяснение кода для управления семисегментным индикатором на ATmega

В данном примере реализовано управление семисегментным индикатором с использованием порта `PORTB` для вывода данных и порта `PORTD` для считывания состояния кнопок.

---

## Инициализация портов

### Функция `initPorts`
```c
void initPorts(void) {
    DDRD = 0x00;       // Все пины PORTD настроены как входы
    PORTD = 0xFF;      // Включены подтягивающие резисторы на всех пинах PORTD

    DDRB = 0xFF;       // Все пины PORTB настроены как выходы
    PORTB = 0x00;      // Все выходы PORTB установлены в низкий уровень
}
```

1. **Порт `PORTD`**:
    - Устанавливается как вход (`DDRD = 0x00`), т.е. все пины `PD0` - `PD7` читают внешние сигналы.
    - Включаются подтягивающие резисторы (`PORTD = 0xFF`), чтобы избежать "плавающих" значений при отсутствии нажатий.

2. **Порт `PORTB`**:
    - Устанавливается как выход (`DDRB = 0xFF`), чтобы передавать данные на семисегментный индикатор.
    - Все выходы изначально обнуляются (`PORTB = 0x00`).

---

## Считывание состояния кнопок

### Функция `readButtonGroup`
```c
uint8_t readButtonGroup(uint8_t mask, uint8_t shift) {
    return (~PIND & mask) >> shift;
}
```

- Читает состояние кнопок с порта `PORTD`.
- Применяются побитовые операции:
    1. Инверсия `~PIND` для учета подтягивающих резисторов (нажатая кнопка = `0`, ненажатая = `1`).
    2. Маска `mask` выделяет определенную группу кнопок.
    3. Сдвиг вправо `>> shift` нормализует позиции битов в младшие разряды.

Пример:
- `readButtonGroup(0x0F, 0)` считывает состояние младших кнопок (`PD0` - `PD3`).
- `readButtonGroup(0xF0, 4)` считывает состояние старших кнопок (`PD4` - `PD7`).

---

## Обновление семисегментного индикатора

### Функция `updateSegmentDisplay`
```c
void updateSegmentDisplay(uint8_t lowerNibble, uint8_t upperNibble) {
    PORTB = (PORTB & 0xF0) | lowerNibble;           // Обновление младших 4 бит (PB0 - PB3)
    PORTB = (PORTB & 0x0F) | (upperNibble << 4);    // Обновление старших 4 бит (PB4 - PB7)
}
```

- Семисегментный индикатор разделен на два набора бит:
    - **Младшие биты** (`PB0` - `PB3`) отображают младшую часть.
    - **Старшие биты** (`PB4` - `PB7`) отображают старшую часть.
- Для обновления:
    - Сохраняются старые значения, которые не обновляются (`&` с маской).
    - Новые значения записываются в нужные позиции с использованием `|` и побитового сдвига.

---

## Основной цикл

### Главная программа
```c
int main(void) {
    initPorts(); // Инициализация портов

    while (1) {
        uint8_t lowerButtons = readButtonGroup(0x0F, 0); // Чтение младших кнопок
        uint8_t upperButtons = readButtonGroup(0xF0, 4); // Чтение старших кнопок

        updateSegmentDisplay(lowerButtons, upperButtons); // Обновление индикатора
    }

    return 0;
}
```

1. **Инициализация портов**: Вызывается `initPorts()`, чтобы настроить `PORTD` и `PORTB`.
2. **Считывание кнопок**:
    - `lowerButtons`: Считывает состояние кнопок `PD0` - `PD3`.
    - `upperButtons`: Считывает состояние кнопок `PD4` - `PD7`.
3. **Обновление индикатора**:
    - Передает значения кнопок для отображения на семисегментном индикаторе через `PORTB`.

---

## Использованные регистры

1. **`DDRx` (Data Direction Register)**:
    - Управляет направлением портов:
        - `1` - вывод.
        - `0` - ввод.

2. **`PORTx` (Data Register)**:
    - Управляет состоянием выходных пинов.
    - Для входных пинов включает подтягивающие резисторы.

3. **`PINx` (Input Register)**:
    - Чтение состояния входных пинов.

---

## Итоговая схема работы

1. Кнопки на `PORTD` задают число.
2. Число считывается через функции обработки (`readButtonGroup`).
3. Обновленное значение отображается на семисегментном индикаторе, подключенном к `PORTB`.
