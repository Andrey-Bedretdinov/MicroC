# Объяснение кода: Реализация счетчика с использованием внешних прерываний

Этот код реализует счетчик, который увеличивает или уменьшает значение при срабатывании внешних прерываний на пинах `INT0` (увеличение) и `INT1` (уменьшение). Текущее значение отображается на семисегментном индикаторе через порт `PORTB`.

---

## Основные компоненты

1. **Прерывания INT0 и INT1**:
    - `INT0` (пин `PD2`): Увеличивает значение на единицу.
    - `INT1` (пин `PD3`): Уменьшает значение на единицу.

2. **Семисегментный индикатор**:
    - Использует `PORTB` для отображения значения (десятки и единицы).

---

## Настройка внешних прерываний

### Конфигурация прерываний

```c
EICRA |= (1 << ISC01) | (1 << ISC11); // Прерывания по спадающему фронту
EIMSK |= (1 << INT0) | (1 << INT1);   // Разрешить прерывания INT0 и INT1
sei(); // Включаем глобальные прерывания
```

1. **`EICRA`** (External Interrupt Control Register A):
    - `ISC01`: Прерывание `INT0` срабатывает на спадающем фронте.
    - `ISC11`: Прерывание `INT1` срабатывает на спадающем фронте.

2. **`EIMSK`** (External Interrupt Mask Register):
    - `INT0` и `INT1`: Разрешает использование прерываний `INT0` и `INT1`.

3. **`sei()`**:
    - Включает глобальные прерывания, позволяя их обработку.

---

## Обработчики прерываний

### Увеличение значения (`INT0_vect`)

```c
ISR(INT0_vect) {
    if (value < 99) value++;
}
```

- Срабатывает при спадающем фронте на пине `PD2`.
- Увеличивает значение переменной `value`, если оно меньше 99.

---

### Уменьшение значения (`INT1_vect`)

```c
ISR(INT1_vect) {
    if (value > 0) value--;
}
```

- Срабатывает при спадающем фронте на пине `PD3`.
- Уменьшает значение переменной `value`, если оно больше 0.

---

## Отображение значения на индикаторе

### Функция `display_number`

```c
void display_number(uint8_t number) {
    uint8_t digit1 = number / 10;  // Десятки
    uint8_t digit2 = number % 10;  // Единицы

    // Вывод десятков (PB4-PB7)
    PORTB = (PORTB & 0x0F) | (digit1 << 4);

    // Вывод единиц (PB0-PB3)
    PORTB = (PORTB & 0xF0) | (digit2 & 0x0F);
}
```

1. **Разделение числа**:
    - `digit1`: Десятки (старший разряд числа).
    - `digit2`: Единицы (младший разряд числа).

2. **Формирование данных для индикатора**:
    - Десятки выводятся на старшие биты `PB4-PB7`.
    - Единицы выводятся на младшие биты `PB0-PB3`.

---

## Основной цикл

### Главная функция `main`

```c
int main(void) {
    DDRB = 0xFF;  // Настройка порта B как выходного
    PORTB = 0x00; // Инициализация порта B

    EICRA |= (1 << ISC01) | (1 << ISC11); // Настройка внешних прерываний
    EIMSK |= (1 << INT0) | (1 << INT1);   // Разрешение внешних прерываний

    sei(); // Включаем глобальные прерывания

    while (1) {
        display_number(value);  // Отображение текущего значения
        _delay_ms(10);          // Задержка для стабилизации
    }
}
```

1. **Инициализация портов**:
    - `PORTB`: Используется для вывода данных на семисегментный индикатор.

2. **Настройка прерываний**:
    - `INT0` и `INT1` настраиваются для обработки изменений на пинах `PD2` и `PD3`.

3. **Основной цикл**:
    - В цикле отображается текущее значение `value` на индикаторе.
    - Используется задержка `_delay_ms(10)` для обеспечения стабильной работы.

---

## Использованные регистры

1. **`DDRB`**: Настройка направления порта `PORTB` как выходного.
2. **`PORTB`**: Управление семисегментным индикатором.
3. **`EICRA`**:
    - `ISC01`: Настройка прерывания `INT0` по спадающему фронту.
    - `ISC11`: Настройка прерывания `INT1` по спадающему фронту.
4. **`EIMSK`**: Включение внешних прерываний `INT0` и `INT1`.
5. **`sei()`**: Включение глобальных прерываний.

---

## Итоговая схема работы

1. **Прерывания**:
    - При нажатии кнопки, подключенной к `PD2` (`INT0`), значение счетчика увеличивается.
    - При нажатии кнопки, подключенной к `PD3` (`INT1`), значение счетчика уменьшается.

2. **Отображение на индикаторе**:
    - Значение счетчика разделяется на десятки и единицы и выводится на семисегментный индикатор через `PORTB`.

3. **Стабильная работа**:
    - Обновление индикатора происходит в бесконечном цикле с минимальной задержкой.