# Объяснение кода: Вывод числа, поступающего через UART, на семисегментный индикатор

Этот код считывает число через интерфейс UART и отображает его на двух семисегментных индикаторах, подключенных к порту `PORTB`. Младший разряд числа выводится на младшую часть порта, старший разряд — на старшую.

---

## Общая структура программы

1. **Инициализация UART**:
    - Настройка UART для работы на скорости 9600 бод с форматом 8N1 (8 данных, 1 стоп-бит, без проверки четности).

2. **Обработка данных через UART**:
    - Принимаются символы через UART и преобразуются в число, завершающееся символом переноса строки (`\r` или `\n`).

3. **Отображение числа на семисегментных индикаторах**:
    - Младший разряд числа выводится на младшие 4 бита порта `PORTB`, старший разряд — на старшие 4 бита.

---

## Инициализация UART

### Функция `UART_Init`

```c
void UART_Init() {
    uint16_t ubrr_value = 51; // Конфигурация для 9600 бод на частоте 8 МГц
    UBRR0H = (ubrr_value >> 8);
    UBRR0L = ubrr_value;

    UCSR0B = (1 << TXEN0) | (1 << RXEN0); // Включение передатчика и приёмника
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // Формат: 8 бит, 1 стоп-бит
}
```

- **UBRR0H/UBRR0L**: Настраивает скорость UART.  
  Формула для расчета UBRR: UBRR = (F_CPU / (16 * UART_BAUD)) - 1.  
  Для F_CPU = 8 МГц и UART_BAUD = 9600, UBRR = (8000000 / (16 * 9600)) - 1 = 51.
- **UCSR0B**: Включает передатчик (TXEN0) и приёмник (RXEN0).
- **UCSR0C**: Настраивает формат данных: 8 бит, 1 стоп-бит, без проверки четности.

---

## Считывание данных через UART

### Функция `UART_ReadChar`

```c
char UART_ReadChar() {
    while (!(UCSR0A & (1 << RXC0))); // Ожидание данных
    return UDR0;
}
```

- **UCSR0A**: Проверяет, получены ли данные (бит RXC0).
- **UDR0**: Содержит принятый байт.

---

## Управление семисегментными индикаторами

### Таблица отображения цифр

```c
const uint8_t segment_map[] = {
    0b0000, // 0
    0b0001, // 1
    0b0010, // 2
    0b0011, // 3
    0b0100, // 4
    0b0101, // 5
    0b0110, // 6
    0b0111, // 7
    0b1000, // 8
    0b1001, // 9
};
```

- Таблица сопоставляет цифры с битовыми шаблонами для семисегментного индикатора.

### Функция `DisplayDigitLow`

```c
void DisplayDigitLow(uint8_t digit) {
    if (digit >= 10) return;  // Проверка корректности значения
    DDRB |= SEG_LOW_MASK;     // Настройка младших битов порта B как выходы
    PORTB = (PORTB & SEG_HIGH_MASK) | segment_map[digit]; // Обновление младших бит
}
```

- Выводит цифру на младшую часть порта (PB0–PB3).

### Функция `DisplayDigitHigh`

```c
void DisplayDigitHigh(uint8_t digit) {
    if (digit >= 10) return;  // Проверка корректности значения
    DDRB |= SEG_HIGH_MASK;    // Настройка старших битов порта B как выходы
    PORTB = (PORTB & SEG_LOW_MASK) | (segment_map[digit] << 4); // Обновление старших бит
}
```

- Выводит цифру на старшую часть порта (PB4–PB7).

---

## Основной цикл

### Функция `main`

```c
int main(void) {
    UART_Init(); // Инициализация UART

    char input_buffer[3]; // Буфер для хранения введённых символов
    uint8_t buffer_index = 0;

    while (1) {
        char received_char = UART_ReadChar();

        // Обработка завершения ввода строки
        if (received_char == '\r' || received_char == '\n') {
            input_buffer[buffer_index] = '\0'; // Завершение строки

            if (buffer_index > 0) {
                // Преобразование символов в цифры и отображение
                uint8_t first_digit = (input_buffer[0] >= '0' && input_buffer[0] <= '9')
                                        ? input_buffer[0] - '0' : 0;
                uint8_t second_digit = (buffer_index > 1 && input_buffer[1] >= '0' && input_buffer[1] <= '9')
                                         ? input_buffer[1] - '0' : 0;

                DisplayDigitLow(second_digit);
                DisplayDigitHigh(first_digit);
            }

            buffer_index = 0; // Сброс индекса буфера
        }
        // Добавление цифры в буфер, если символ допустим
        else if (received_char >= '0' && received_char <= '9' && buffer_index < 2) {
            input_buffer[buffer_index++] = received_char;
        }
    }

    return 0;
}
```

1. Приём данных через UART:
    - Символы добавляются в буфер, пока не встретится `\r` или `\n`.
2. Преобразование строки в цифры:
    - Первый символ буфера — старший разряд, второй символ — младший.
3. Вывод на индикаторы:
    - Младший разряд выводится на младшую часть порта, старший — на старшую.

---

## Итоговая схема работы

1. **Приём данных через UART**: Принимаются символы, формирующие число.
2. **Обработка данных**: Преобразование строки в разряды числа.
3. **Вывод на семисегментные индикаторы**: Отображение числа в реальном времени.  