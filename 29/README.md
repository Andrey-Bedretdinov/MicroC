# Объяснение кода: Отображение напряжения с АЦП на семисегментном индикаторе

Этот код предназначен для считывания напряжения с аналогового входа `PC0` микроконтроллера с помощью АЦП и отображения этого значения на семисегментном индикаторе через порт `PORTB`.

---

## Общая структура программы

1. **Инициализация системы**:
   - Настраивается порт `PORTB` для управления семисегментным индикатором.
   - Конфигурируется модуль АЦП для считывания данных с аналогового входа `PC0`.

2. **Считывание данных с АЦП**:
   - Напряжение преобразуется из значения АЦП в физическое значение (вольты).

3. **Отображение напряжения**:
   - Напряжение преобразуется в формат, подходящий для отображения на семисегментном индикаторе.

---

## Инициализация системы

### Функция `initialize_system`

```c
void initialize_system() {
    DDRB = 0xFF; // Устанавливаем все пины порта B как выходы
    ADMUX |= (1 << REFS0); // Опорное напряжение: внутреннее (AVcc)
    ADCSRA |= (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1); // Включаем АЦП, предделитель 64
}
```

1. **`DDRB`**:  
   Устанавливает порт `PORTB` как выходной для управления семисегментным индикатором.

2. **`ADMUX`**:  
   Опорное напряжение `AVcc` задается установкой бита `REFS0`.  
   Входной канал по умолчанию `ADC0` (соответствует пину `PC0`).

3. **`ADCSRA`**:  
   Включает АЦП установкой бита `ADEN`.  
   Устанавливает предделитель частоты в 64 (биты `ADPS2` и `ADPS1`), обеспечивая стабильную работу АЦП при тактовой частоте 8 МГц.

---

## Считывание данных с АЦП

### Функция `read_adc_voltage`

```c
void read_adc_voltage() {
    ADCSRA |= (1 << ADSC); // Запуск преобразования
    while (!(ADCSRA & (1 << ADIF))); // Ожидание завершения
    uint16_t adc_value = ADC; // Чтение результата
    current_voltage = adc_value * ADC_TO_VOLTAGE_COEFF; // Преобразование в вольты
    _delay_ms(1); // Задержка для стабилизации
}
```

1. **`ADCSRA`**:  
   Бит `ADSC` запускает преобразование.  
   Бит `ADIF` указывает на завершение преобразования.

2. **`ADC`**:  
   Содержит 10-битный результат преобразования (значение от 0 до 1023).

3. **`current_voltage`**:  
   Рассчитывается по формуле: V = (ADC_Value * 5.0) / 1023.

---

## Отображение напряжения на индикаторе

### Функция `convert_to_binary`

```c
uint8_t convert_to_binary(uint8_t value) {
    uint8_t binary_result = 0;
    for (uint8_t i = 0; i < 4; ++i) {
        if (value % 2 == 1) {
            binary_result |= (1 << i);
        }
        value /= 2;
    }
    return binary_result;
}
```

- Преобразует десятичное значение (0–15) в 4-битный двоичный код для отображения на семисегментном индикаторе.

---

### Функция `display_voltage_on_indicator`

```c
void display_voltage_on_indicator() {
    uint8_t integer_part = (uint8_t)current_voltage; // Целая часть
    uint8_t fractional_part = (uint8_t)((current_voltage - integer_part) * 10); // Первая цифра после запятой

    uint8_t integer_binary = convert_to_binary(integer_part); // Целая часть в двоичном виде
    uint8_t fractional_binary = convert_to_binary(fractional_part); // Дробная часть в двоичном виде

    PORTB = (integer_binary << 4) | fractional_binary; // Вывод на индикатор
}
```

1. **Разделение на целую и дробную части**:  
   Целая часть: integer_part.  
   Первая цифра после запятой: fractional_part.

2. **Формирование данных для индикатора**:  
   Целая часть занимает старшие 4 бита (PB4 - PB7).  
   Дробная часть занимает младшие 4 бита (PB0 - PB3).

---

## Главный цикл

### Функция `main`

```c
int main() {
    initialize_system(); // Инициализация системы

    while (1) {
        read_adc_voltage(); // Считываем значение напряжения
        display_voltage_on_indicator(); // Отображаем на индикаторе
    }
}
```

- **Считывание напряжения**:  
  Значение с входа PC0 обрабатывается через АЦП.
- **Отображение значения**:  
  Напряжение отображается на семисегментном индикаторе через PORTB.

---

## Использованные регистры

1. **ADMUX**:  
   Бит REFS0 устанавливает опорное напряжение AVcc.

2. **ADCSRA**:  
   Бит ADEN включает АЦП.  
   Бит ADSC запускает преобразование.  
   Бит ADIF указывает завершение преобразования.  
   Биты ADPS2 и ADPS1 устанавливают предделитель 64.

3. **ADC**:  
   Содержит 10-битный результат преобразования.

4. **PORTB**:  
   Управляет семисегментным индикатором.

---

## Итоговая схема работы

1. **Считывание напряжения**:  
   Напряжение на входе PC0 преобразуется в цифровое значение.
2. **Отображение значения**:  
   Цифровое значение преобразуется в напряжение и отображается в виде целой и дробной частей на семисегментном индикаторе.
3. **Обновление данных**:  
   Обновление происходит в реальном времени в бесконечном цикле.  